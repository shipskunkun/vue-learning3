#### 15-2视频: 图片上传需求分析

1. 上传按钮
   1. 点击上传
   2. 自动上传
2. 上传前验证
   1. 图片类型
   2. 图片大小

2. loading，显示上传进度

3. 拖拽上传

4. 上传结果

   1. 图片预览
   2. 失败提示

5. 点击保存

   1. 从 input 中拿到上传结果

   



#### 15-3视频: 图片上传接口设计

上传地址

请求头

上传附带参数

是否发送cookie凭证，因为跨域默认不带cookie

是否多文件

是否支持拖拽上传

接受文件类型

钩子函数

​	成功钩子

​	失败钩子

​	进行钩子

​	上传前钩子

​	



#### 15-4视频: 图片上传后台实现

接受图片，并存储起来

生成index.js

```js
npm init  -y  //生成package.json
npm install express multer cors 安装依赖

代码的意思
引入express
生成APP
路径匹配，如果是根路径，发送 hello nodejs

const express = require('express')
const app = express()
app.get('/', (req, res, next)=> {
	res.send('hello nodejs')
})
app.lisen(3000)


执行 node index.js
访问首页，根路径，页面显示，hello nodejs


使用 post 提交文件：

<form action="http:/127.0.0.1:3000/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="test">
  <input type="submit" value="提交">
</form>

app.post('/upload', (req, res)=>{
  res.send('here')
})

如何拿到文件？
使用 upload 插件，把获取的文件，放入某个文件夹 yyy 中

const upload = multer({dest:'yyy/'})
app.post('/upload', upload.single('test'), (req, res)=>{  //和input name 对应起来
  res.send(req.file.filename)// 返回上传成功的文件名
})


上传文件必须：
文件名
action、method、enctype

```



#### 15-4视频: ajax实现文件上传



注意，input file 文件，是通过 formData  收集数据，发送给后端的

formData.append 包装数据 ，通过 ajax 请求发送出去

```

```

存在跨域问题

后端如何添加响应头，我允许任何域请求访问我这个接口

```js
app.post('/upload', upload.single('test'), (req, res)=>{  //和input name 对应起来
  //只需要添加这一句
  res.set('Acess-Control-Allow-Origin', '*')
  
  res.set('Acess-Control-Allow-Origin', 'https:jsbin')  //只允许这个域访问
  
  res.send(req.file.filename)// 返回上传成功的文件名
}
```



后面代码的逻辑：匹配url prams 中id， 从创建的文件夹 yyy 中找对应id 的图片

```js
app.get('/preview/:key',(req, res)=> {
  res.sendFile('yyy/${req.params.key}', {
    
  })
})
```

上传回调：

img src = 从后端返回的 图片路径，就可以预览刚才上传的文件



#### 15-6视频: 使用heroku当做服务器

提供一个nodejs运行的服务器，不需要买服务器

如何让nodejs 文件在服务器上运行？

​	把代码放到github 中，在 heroku 中配置 github 地址， 点击 connet

​	机器会自动部署我们的代码

​	点击，depoly branch， 真正部署服务



网站很智能，访问的时候开机，不访问就关机

！不需要买服务器就能访问，nice

heroku, 免费服务器，非常方便





#### 15-7视频: 为heroku添加npm start

https://github.com/FrankFang/node-server-1/blob/master/index.js

他写的，服务端完整地址

```js
const express = require('express');
const multer = require('multer');
const cors = require('cors');
const upload = multer({ dest: 'uploads/' });

const app = express();

app.get('/', (req, res) => {
  res.send('hello nodejs');
});

app.options('/upload', cors());
app.post('/upload', cors(), upload.single('file'), (req, res) => {
  res.send(req.file.filename);
});

app.get('/preview/:key', cors(), (req, res) => {
  res.sendFile(
    `uploads/${req.params.key}`,
    {
      root: __dirname,
      headers: {
        'Content-Type': 'image/jpeg',
      },
    },
    error => {
      console.log(error);
    }
  );
});

var port = process.env.PORT || 3000;
console.log(port);
app.listen(port);
```



#### 15-8视频: 初步实现uploader

为什么服务器不直接把对象传给前端？

为什么要序列化，和反序列化

因为，http协议只支持字符串、或者二进制（图片、文件）



对耦合性比较大的代码，进行解耦

如果一个函数超过5行，说明可以优化



功能：上传多个图片，新上传的不是覆盖旧图，而是全都展示

所以，上传成功后的图片，是一个对象数组

思路：

上传成功，this.fileList.push ，数组添加新对象



问题：如何区分两个完全一样的文件

name、url、type 都相同

强制规定，图片获取的数值中，返回唯一id





#### 15-9视频: 删除功能

找到位置， indexOf， splice



#### 15-10视频: 显示上传中

#### 15-11视频: update拼成upload造成 bug

#### 15-12视频: 渲染任务是异步执行的！

#### 15-13视频: 完善CSS

#### 15-14视频: UI细节完善

#### 15-15创建uploader

